#!/usr/bin/env python3
"""
Testing Subagent
Creates and manages automated tests for the React application
"""

import os
import re
from pathlib import Path
from typing import Dict, Any


class TestingAgent:
    """
    Specialized subagent for creating automated tests

    Responsibilities:
    - Generate comprehensive test suite
    - Write unit tests for components
    - Write integration tests
    - Create end-to-end tests
    - Set up testing infrastructure
    - Provide test coverage analysis
    """

    def __init__(self, orchestrator):
        """
        Initialize testing agent

        Args:
            orchestrator: Reference to parent orchestrator
        """
        self.orchestrator = orchestrator
        self.name = "testing"

    def create_test_files(self, response: str) -> Dict[str, Any]:
        """
        Parse Claude's response and create actual test files

        Args:
            response: Claude's testing response with test code

        Returns:
            Dictionary with created test files info
        """
        # Create tests directory in output folder
        tests_dir = os.path.join(self.orchestrator.output_dir, "__tests__")
        Path(tests_dir).mkdir(parents=True, exist_ok=True)

        created_files = []

        # Pattern to match test code blocks with file paths
        # Supports: ```javascript, ```js, ```jsx, ```typescript, ```ts, ```tsx
        test_block_pattern = r'```(?:javascript|jsx?|typescript|tsx?)\s*\n(?:\/\/|#)\s*(?:filename:|path:|file:)\s*([^\n]+?)\s*\n(.*?)```'

        matches = re.finditer(test_block_pattern, response, re.DOTALL | re.IGNORECASE)

        for match in matches:
            filepath = match.group(1).strip()
            code_content = match.group(2).strip()

            # Clean up filepath
            filepath = filepath.replace('`', '').strip()

            # Skip if filepath looks invalid
            if not filepath or filepath.startswith('```') or filepath.startswith('{') or len(filepath) < 3:
                continue

            # Determine full path
            filename_only = os.path.basename(filepath)

            # Test configuration files go to root
            if filename_only in ['jest.config.js', 'jest.setup.js', 'cypress.config.js', '.eslintrc.js']:
                full_path = os.path.join(self.orchestrator.output_dir, filename_only)
            # If path includes __tests__ or .test. or .spec., preserve structure
            elif '__tests__' in filepath or '.test.' in filepath or '.spec.' in filepath:
                if filepath.startswith('__tests__/') or filepath.startswith('tests/'):
                    full_path = os.path.join(self.orchestrator.output_dir, filepath)
                elif filepath.startswith('src/'):
                    full_path = os.path.join(self.orchestrator.output_dir, filepath)
                else:
                    # Default to __tests__ directory
                    full_path = os.path.join(tests_dir, filepath)
            else:
                # Put other test files in __tests__
                full_path = os.path.join(tests_dir, filepath)

            # Create directory if needed
            Path(os.path.dirname(full_path)).mkdir(parents=True, exist_ok=True)

            # Write file
            try:
                with open(full_path, 'w') as f:
                    f.write(code_content)
                created_files.append(full_path)
                print(f"  âœ“ Created: {os.path.relpath(full_path, self.orchestrator.output_dir)}")
            except Exception as e:
                print(f"  âœ— Failed to create {filepath}: {e}")

        # Create test README if tests were created
        if created_files:
            test_readme_path = os.path.join(self.orchestrator.output_dir, "TESTING.md")
            test_readme_content = """# Testing Guide

## Running Tests

### Unit Tests (Jest + React Testing Library)
```bash
npm test
```

### Run tests in watch mode
```bash
npm test -- --watch
```

### Generate coverage report
```bash
npm test -- --coverage
```

### End-to-End Tests (Cypress)
```bash
npm run cypress:open
```

## Test Structure

```
__tests__/          # Unit and integration tests
â”œâ”€â”€ components/     # Component tests
â”œâ”€â”€ integration/    # Integration tests
â””â”€â”€ utils/          # Utility function tests
```

## Writing Tests

- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test component interactions
- **E2E Tests**: Test complete user flows

## Coverage Goals

- Maintain minimum 80% code coverage
- Critical paths should have 100% coverage
- All user-facing features must have E2E tests

## Generated by Claude Code Orchestrator

This test suite was automatically generated. Review and customize as needed.
"""
            try:
                with open(test_readme_path, 'w') as f:
                    f.write(test_readme_content)
                created_files.append(test_readme_path)
                print(f"  âœ“ Created: TESTING.md")
            except Exception as e:
                print(f"  âœ— Failed to create TESTING.md: {e}")

        return {
            "files_created": len(created_files),
            "files": [os.path.relpath(f, self.orchestrator.output_dir) for f in created_files]
        }

    def execute(self, requirements: str, implementation_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute testing phase

        Args:
            requirements: Original user requirements
            implementation_result: Output from implementation phase

        Returns:
            Test suite and testing documentation
        """
        print("\n" + "="*70)
        print("ðŸ§ª TESTING PHASE")
        print("="*70)

        print("\n[Step 1/7] Extracting implementation details...")
        # Extract implementation details
        implementation_code = implementation_result.get("response", "")
        print(f"  Implementation code length: {len(implementation_code)} characters")

        # Check if source files info is available
        source_files = implementation_result.get("source_files", {})
        if source_files:
            files_count = source_files.get("files_created", 0)
            print(f"  Source files created: {files_count}")

        print("\n[Step 2/7] Building testing strategy prompt...")
        # Create comprehensive testing prompt
        testing_prompt = f"""You are a senior QA engineer and testing expert. Create a comprehensive automated testing suite for the React application.

ORIGINAL REQUIREMENTS:
{requirements}

IMPLEMENTATION DETAILS:
{implementation_code}

Please provide:

1. TESTING STRATEGY
   - Testing approach overview
   - What to test at each level (unit, integration, e2e)
   - Testing priorities

2. TEST SETUP
   - Testing frameworks and libraries to use (Jest, React Testing Library, Cypress, etc.)
   - Configuration files needed
   - Setup instructions

3. UNIT TESTS
   For each major component:
   - Test file structure
   - Test cases for different scenarios
   - Mock data and fixtures
   - Props testing
   - State testing
   - Event handler testing

4. INTEGRATION TESTS
   - Test component interactions
   - Test data flow between components
   - Test state management
   - API integration tests (if applicable)

5. END-TO-END TESTS
   - User flow tests
   - Critical path testing
   - Edge case scenarios

6. TEST UTILITIES
   - Custom render functions
   - Test helpers
   - Mock utilities
   - Fixtures and factories

7. ACCESSIBILITY TESTS
   - ARIA label tests
   - Keyboard navigation tests
   - Screen reader compatibility

8. PACKAGE DEPENDENCIES
   - Testing packages needed
   - DevDependencies for package.json

9. TEST COMMANDS
   - npm scripts for running tests
   - Coverage commands
   - Watch mode

10. COVERAGE GOALS
    - Target coverage percentages
    - Critical paths that need 100% coverage

IMPORTANT: Provide all test code in properly formatted code blocks with file paths.
Use this format for EVERY test file:

```javascript
// filename: __tests__/components/ComponentName.test.js
[test code here]
```

```javascript
// filename: jest.config.js
[configuration code here]
```

```javascript
// filename: __tests__/utils/testHelpers.js
[helper code here]
```

Provide complete, working test code that follows testing best practices. Include both Jest/RTL tests and E2E tests where appropriate."""
        print(f"  Testing prompt prepared ({len(testing_prompt)} characters)")

        print("\n[Step 3/7] Delegating to Claude API...")
        print("  Sending test generation task to AI subagent")

        # Delegate to orchestrator
        result = self.orchestrator.delegate_to_subagent(
            subagent_name=self.name,
            prompt=testing_prompt,
            context={
                "phase": "testing",
                "testing_frameworks": "Jest, React Testing Library, Cypress",
                "output_format": "complete test suite with setup instructions"
            }
        )

        print("\n[Step 4/7] Processing testing response...")
        if result.get("success"):
            response_text = result.get("response", "")
            response_length = len(response_text)
            print(f"  Response received ({response_length} characters)")
            print("  Parsing test code from response")

            print("\n[Step 5/7] Extracting test code blocks...")
            # Count test code blocks in response
            import re
            test_blocks = re.findall(r'```(?:javascript|jsx?|typescript|tsx?)', response_text)
            print(f"  Found {len(test_blocks)} test code blocks to extract")

            # Extract and create test files
            print("\n[Step 6/7] Creating test files...")
            files_info = self.create_test_files(response_text)
            print(f"  Created {files_info['files_created']} test files")

            # Add files info to result
            result["test_files"] = files_info

            print("\n[Step 7/7] Finalizing testing phase...")
            print("\nâœ“ Test suite created successfully")
            print("\nTesting deliverables:")
            print("  - Testing strategy defined")
            print("  - Unit tests for components")
            print("  - Integration tests")
            print("  - End-to-end tests")
            print("  - Test utilities and helpers")
            print("  - Setup and run instructions")
            print(f"  - {files_info['files_created']} test files created in __tests__/")
        else:
            error = result.get("error", "Unknown error")
            print(f"  Error occurred: {error}")
            print("\n[Step 7/7] Testing phase failed")
            print("\nâœ— Testing phase failed")

        return result


if __name__ == "__main__":
    # For testing the agent standalone
    print("Testing Agent - use through orchestrator")
