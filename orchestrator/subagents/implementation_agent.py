#!/usr/bin/env python3
"""
Implementation Subagent
Implements React UI based on design specifications
"""

import os
import re
from pathlib import Path
from typing import Dict, Any


class ImplementationAgent:
    """
    Specialized subagent for implementing React UI

    Responsibilities:
    - Convert design specs to React components
    - Write clean, maintainable React code
    - Implement state management
    - Add proper TypeScript types (if applicable)
    - Follow React best practices
    - Create reusable component library
    """

    def __init__(self, orchestrator):
        """
        Initialize implementation agent

        Args:
            orchestrator: Reference to parent orchestrator
        """
        self.orchestrator = orchestrator
        self.name = "implementation"

    def create_source_files(self, response: str) -> Dict[str, Any]:
        """
        Parse Claude's response and create actual source files

        Args:
            response: Claude's implementation response with code

        Returns:
            Dictionary with created files info
        """
        # Create src directory in output folder
        src_dir = os.path.join(self.orchestrator.output_dir, "src")
        Path(src_dir).mkdir(parents=True, exist_ok=True)

        created_files = []

        # Pattern to match code blocks with file paths
        # Looks for: ```jsx or ```javascript or ```js or ```tsx
        # Followed by // filename: path/to/file.js or similar
        code_block_pattern = r'```(?:jsx?|tsx?|javascript|typescript|json|css)\s*\n(?:\/\/|#|<!--)\s*(?:filename:|path:|file:)\s*([^\n]+?)\s*(?:-->)?\s*\n(.*?)```'

        matches = re.finditer(code_block_pattern, response, re.DOTALL | re.IGNORECASE)

        for match in matches:
            filepath = match.group(1).strip()
            code_content = match.group(2).strip()

            # Clean up filepath
            filepath = filepath.replace('`', '').strip()

            # Skip if filepath looks invalid
            if not filepath or filepath.startswith('```') or filepath.startswith('{') or len(filepath) < 3:
                continue

            # Determine full path
            # Special files go to root
            filename_only = os.path.basename(filepath)
            if filename_only in ['package.json', 'package-lock.json', '.gitignore', 'README.md', 'tsconfig.json']:
                full_path = os.path.join(self.orchestrator.output_dir, filename_only)
            elif filepath.startswith('src/'):
                full_path = os.path.join(self.orchestrator.output_dir, filepath)
            elif filepath.startswith('/'):
                full_path = os.path.join(src_dir, filepath.lstrip('/'))
            else:
                full_path = os.path.join(src_dir, filepath)

            # Create directory if needed
            Path(os.path.dirname(full_path)).mkdir(parents=True, exist_ok=True)

            # Write file
            try:
                with open(full_path, 'w') as f:
                    f.write(code_content)
                created_files.append(full_path)
                print(f"  ‚úì Created: {os.path.relpath(full_path, self.orchestrator.output_dir)}")
            except Exception as e:
                print(f"  ‚úó Failed to create {filepath}: {e}")

        # Also try to extract package.json if present with proper filename marker
        package_json_match = re.search(r'```json\s*\n(?:\/\/|#)\s*filename:\s*package\.json\s*\n(.*?)```', response, re.DOTALL | re.IGNORECASE)
        if package_json_match and 'package.json' not in [os.path.basename(f) for f in created_files]:
            package_json_path = os.path.join(self.orchestrator.output_dir, "package.json")
            try:
                with open(package_json_path, 'w') as f:
                    f.write(package_json_match.group(1).strip())
                created_files.append(package_json_path)
                print(f"  ‚úì Created: package.json")
            except Exception as e:
                print(f"  ‚úó Failed to create package.json: {e}")

        # Create README with setup instructions if not already present
        readme_path = os.path.join(self.orchestrator.output_dir, "README.md")
        if not os.path.exists(readme_path):
            readme_content = """# React Application

## Setup Instructions

1. Install dependencies:
   ```bash
   npm install
   ```

2. Start development server:
   ```bash
   npm start
   ```

3. Build for production:
   ```bash
   npm run build
   ```

## Project Structure

```
src/
‚îú‚îÄ‚îÄ components/    # React components
‚îú‚îÄ‚îÄ styles/        # CSS styles
‚îú‚îÄ‚îÄ hooks/         # Custom hooks
‚îî‚îÄ‚îÄ utils/         # Utility functions
```

## Generated by Claude Code Orchestrator

This project was automatically generated. Review the code and customize as needed.
"""
            try:
                with open(readme_path, 'w') as f:
                    f.write(readme_content)
                created_files.append(readme_path)
                print(f"  ‚úì Created: README.md")
            except Exception as e:
                print(f"  ‚úó Failed to create README.md: {e}")

        return {
            "files_created": len(created_files),
            "files": [os.path.relpath(f, self.orchestrator.output_dir) for f in created_files]
        }

    def execute(self, requirements: str, design_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute implementation phase

        Args:
            requirements: Original user requirements
            design_result: Output from design phase

        Returns:
            Implementation details and code
        """
        print("\n" + "="*70)
        print("‚öõÔ∏è  IMPLEMENTATION PHASE (React)")
        print("="*70)

        # Extract design specifications
        design_spec = design_result.get("response", "")

        # Create comprehensive implementation prompt
        implementation_prompt = f"""You are a senior React developer. Implement a React application based on these requirements and design specifications.

ORIGINAL REQUIREMENTS:
{requirements}

DESIGN SPECIFICATIONS:
{design_spec}

Please implement the following:

1. PROJECT STRUCTURE
   - Recommended folder structure
   - File organization (components, hooks, utils, styles)

2. REACT COMPONENTS
   - Implement all components specified in the design
   - Use functional components with hooks
   - Follow React best practices
   - Use proper component composition
   - Implement prop types or TypeScript interfaces

3. STATE MANAGEMENT
   - Determine if local state, Context API, or external library needed
   - Implement state management solution
   - Handle state updates properly

4. STYLING APPROACH
   - Choose styling approach (CSS Modules, styled-components, Tailwind, etc.)
   - Implement the design system specified
   - Create reusable style utilities

5. KEY COMPONENTS CODE
   For each major component, provide:
   - Complete React component code
   - Props interface/types
   - State management
   - Event handlers
   - Styling

6. HOOKS AND UTILITIES
   - Custom hooks if needed
   - Utility functions
   - Helper methods

7. PACKAGE DEPENDENCIES
   - List all npm packages needed
   - Provide package.json dependencies

8. SETUP INSTRUCTIONS
   - How to set up the project
   - Build and run commands

IMPORTANT: Provide all code in properly formatted code blocks with file paths.
Use this format for EVERY code file:

```jsx
// filename: src/components/ComponentName.jsx
[component code here]
```

```css
// filename: src/styles/styles.css
[css code here]
```

```json
// filename: package.json
[package.json content]
```

Provide complete, working React code that can be directly used. Focus on clean, maintainable, production-ready code."""

        # Delegate to orchestrator
        result = self.orchestrator.delegate_to_subagent(
            subagent_name=self.name,
            prompt=implementation_prompt,
            context={
                "phase": "implementation",
                "framework": "React",
                "output_format": "complete React code with setup instructions"
            }
        )

        if result.get("success"):
            print("\n‚úì React implementation completed successfully")

            # Extract and create source files
            print("\nüìÅ Creating source files...")
            response_text = result.get("response", "")
            files_info = self.create_source_files(response_text)

            # Add files info to result
            result["source_files"] = files_info

            print("\nImplementation deliverables:")
            print("  - Project structure defined")
            print("  - React components implemented")
            print("  - State management configured")
            print("  - Styling approach implemented")
            print("  - Dependencies and setup instructions provided")
            print(f"  - {files_info['files_created']} source files created in src/")
        else:
            print("\n‚úó Implementation phase failed")

        return result


if __name__ == "__main__":
    # For testing the agent standalone
    print("Implementation Agent - use through orchestrator")
