#!/usr/bin/env python3
"""
Implementation Subagent
Implements React UI and Python Backend based on design specifications
"""

import os
import re
from pathlib import Path
from typing import Dict, Any


class ImplementationAgent:
    """
    Specialized subagent for implementing full-stack web applications

    Responsibilities:
    FRONTEND:
    - Convert design specs to React components
    - Write clean, maintainable React code
    - Implement state management
    - Add proper TypeScript types (if applicable)
    - Follow React best practices
    - Create reusable component library

    BACKEND:
    - Implement Python backend APIs (Flask/FastAPI/Django)
    - Create RESTful API endpoints
    - Define data models and schemas
    - Handle business logic
    - Configure CORS for frontend integration
    - Provide backend setup instructions
    """

    def __init__(self, orchestrator):
        """
        Initialize implementation agent

        Args:
            orchestrator: Reference to parent orchestrator
        """
        self.orchestrator = orchestrator
        self.name = "implementation"

    def create_backend_files(self, response: str) -> Dict[str, Any]:
        """
        Parse Claude's response and create Python backend files

        Args:
            response: Claude's implementation response with backend code

        Returns:
            Dictionary with created backend files info
        """
        # Create backend directory in output folder
        backend_dir = os.path.join(self.orchestrator.output_dir, "backend")
        Path(backend_dir).mkdir(parents=True, exist_ok=True)

        created_files = []

        # Pattern to match Python code blocks with file paths
        # Also match 'text' for requirements.txt files
        code_block_pattern = r'```(?:python|py|text)\s*\n(?:#|\/\/)\s*(?:filename:|path:|file:)\s*([^\n]+?)\s*\n(.*?)```'

        matches = re.finditer(code_block_pattern, response, re.DOTALL | re.IGNORECASE)

        for match in matches:
            filepath = match.group(1).strip()
            code_content = match.group(2).strip()

            # Clean up filepath
            filepath = filepath.replace('`', '').strip()

            # Skip if filepath looks invalid
            if not filepath or filepath.startswith('```') or filepath.startswith('{') or len(filepath) < 3:
                continue

            # Determine full path
            filename_only = os.path.basename(filepath)

            # Backend config files go to backend root
            if filename_only in ['requirements.txt', 'setup.py', '.env.example', 'README.md', 'Dockerfile']:
                full_path = os.path.join(backend_dir, filename_only)
            elif filepath.startswith('backend/'):
                full_path = os.path.join(self.orchestrator.output_dir, filepath)
            elif filepath.startswith('/'):
                full_path = os.path.join(backend_dir, filepath.lstrip('/'))
            else:
                full_path = os.path.join(backend_dir, filepath)

            # Create directory if needed
            Path(os.path.dirname(full_path)).mkdir(parents=True, exist_ok=True)

            # Write file
            try:
                with open(full_path, 'w') as f:
                    f.write(code_content)
                created_files.append(full_path)
                print(f"  ✓ Created: {os.path.relpath(full_path, self.orchestrator.output_dir)}")
            except Exception as e:
                print(f"  ✗ Failed to create {filepath}: {e}")

        # Create backend README if files were created
        if created_files:
            backend_readme_path = os.path.join(backend_dir, "BACKEND_README.md")
            if not os.path.exists(backend_readme_path):
                backend_readme_content = """# Python Backend API

## Setup Instructions

1. Create a virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\\Scripts\\activate
   ```

2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

3. Set up environment variables:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. Run the development server:
   ```bash
   python app.py
   # or
   uvicorn main:app --reload
   ```

## Project Structure

```
backend/
├── app.py or main.py  # Main application entry point
├── routes/            # API route handlers
├── models/            # Data models
├── services/          # Business logic
└── utils/             # Utility functions
```

## Generated by Claude Code Orchestrator

This backend was automatically generated. Review the code and customize as needed.
"""
                try:
                    with open(backend_readme_path, 'w') as f:
                        f.write(backend_readme_content)
                    created_files.append(backend_readme_path)
                    print(f"  ✓ Created: BACKEND_README.md")
                except Exception as e:
                    print(f"  ✗ Failed to create BACKEND_README.md: {e}")

        return {
            "files_created": len(created_files),
            "files": [os.path.relpath(f, self.orchestrator.output_dir) for f in created_files]
        }

    def create_source_files(self, response: str) -> Dict[str, Any]:
        """
        Parse Claude's response and create actual source files

        Args:
            response: Claude's implementation response with code

        Returns:
            Dictionary with created files info
        """
        # Create src directory in output folder
        src_dir = os.path.join(self.orchestrator.output_dir, "src")
        Path(src_dir).mkdir(parents=True, exist_ok=True)

        created_files = []

        # Pattern to match code blocks with file paths
        # Looks for: ```jsx or ```javascript or ```js or ```tsx
        # Followed by // filename: path/to/file.js or similar
        code_block_pattern = r'```(?:jsx?|tsx?|javascript|typescript|json|css)\s*\n(?:\/\/|#|<!--)\s*(?:filename:|path:|file:)\s*([^\n]+?)\s*(?:-->)?\s*\n(.*?)```'

        matches = re.finditer(code_block_pattern, response, re.DOTALL | re.IGNORECASE)

        for match in matches:
            filepath = match.group(1).strip()
            code_content = match.group(2).strip()

            # Clean up filepath
            filepath = filepath.replace('`', '').strip()

            # Skip if filepath looks invalid
            if not filepath or filepath.startswith('```') or filepath.startswith('{') or len(filepath) < 3:
                continue

            # Determine full path
            # Special files go to root
            filename_only = os.path.basename(filepath)
            if filename_only in ['package.json', 'package-lock.json', '.gitignore', 'README.md', 'tsconfig.json']:
                full_path = os.path.join(self.orchestrator.output_dir, filename_only)
            elif filepath.startswith('src/'):
                full_path = os.path.join(self.orchestrator.output_dir, filepath)
            elif filepath.startswith('/'):
                full_path = os.path.join(src_dir, filepath.lstrip('/'))
            else:
                full_path = os.path.join(src_dir, filepath)

            # Create directory if needed
            Path(os.path.dirname(full_path)).mkdir(parents=True, exist_ok=True)

            # Write file
            try:
                with open(full_path, 'w') as f:
                    f.write(code_content)
                created_files.append(full_path)
                print(f"  ✓ Created: {os.path.relpath(full_path, self.orchestrator.output_dir)}")
            except Exception as e:
                print(f"  ✗ Failed to create {filepath}: {e}")

        # Also try to extract package.json if present with proper filename marker
        package_json_match = re.search(r'```json\s*\n(?:\/\/|#)\s*filename:\s*package\.json\s*\n(.*?)```', response, re.DOTALL | re.IGNORECASE)
        if package_json_match and 'package.json' not in [os.path.basename(f) for f in created_files]:
            package_json_path = os.path.join(self.orchestrator.output_dir, "package.json")
            try:
                with open(package_json_path, 'w') as f:
                    f.write(package_json_match.group(1).strip())
                created_files.append(package_json_path)
                print(f"  ✓ Created: package.json")
            except Exception as e:
                print(f"  ✗ Failed to create package.json: {e}")

        # Create README with setup instructions if not already present
        readme_path = os.path.join(self.orchestrator.output_dir, "README.md")
        if not os.path.exists(readme_path):
            readme_content = """# React Application

## Setup Instructions

1. Install dependencies:
   ```bash
   npm install
   ```

2. Start development server:
   ```bash
   npm start
   ```

3. Build for production:
   ```bash
   npm run build
   ```

## Project Structure

```
src/
├── components/    # React components
├── styles/        # CSS styles
├── hooks/         # Custom hooks
└── utils/         # Utility functions
```

## Generated by Claude Code Orchestrator

This project was automatically generated. Review the code and customize as needed.
"""
            try:
                with open(readme_path, 'w') as f:
                    f.write(readme_content)
                created_files.append(readme_path)
                print(f"  ✓ Created: README.md")
            except Exception as e:
                print(f"  ✗ Failed to create README.md: {e}")

        return {
            "files_created": len(created_files),
            "files": [os.path.relpath(f, self.orchestrator.output_dir) for f in created_files]
        }

    def execute(self, requirements: str, design_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute implementation phase

        Args:
            requirements: Original user requirements
            design_result: Output from design phase

        Returns:
            Implementation details and code
        """
        print("\n" + "="*70)
        print("⚛️  IMPLEMENTATION PHASE (React + Python Backend)")
        print("="*70)

        print("\n[Step 1/9] Extracting design specifications...")
        # Extract design specifications
        design_spec = design_result.get("response", "")
        print(f"  Design spec length: {len(design_spec)} characters")

        print("\n[Step 2/9] Building implementation prompt...")
        # Create comprehensive implementation prompt
        implementation_prompt = f"""You are a senior full-stack developer. Implement a complete web application with React frontend and Python backend based on these requirements and design specifications.

CRITICAL INSTRUCTION: You MUST provide the actual source code files, NOT just descriptions or summaries. Every file must be in a properly formatted code block with a filename comment.

ORIGINAL REQUIREMENTS:
{requirements}

DESIGN SPECIFICATIONS:
{design_spec}

Please implement the following with ACTUAL CODE (not descriptions):

## PART 1: REACT FRONTEND

1. PROJECT STRUCTURE
   - Recommended folder structure
   - File organization (components, hooks, utils, styles)

2. REACT COMPONENTS
   - Implement all components specified in the design
   - Use functional components with hooks
   - Follow React best practices
   - Use proper component composition
   - Implement prop types or TypeScript interfaces

3. STATE MANAGEMENT
   - Determine if local state, Context API, or external library needed
   - Implement state management solution
   - Handle state updates properly

4. STYLING APPROACH
   - Choose styling approach (CSS Modules, styled-components, Tailwind, etc.)
   - Implement the design system specified
   - Create reusable style utilities

5. KEY COMPONENTS CODE
   For each major component, provide:
   - Complete React component code
   - Props interface/types
   - State management
   - Event handlers
   - Styling

6. HOOKS AND UTILITIES
   - Custom hooks if needed
   - Utility functions
   - Helper methods

7. PACKAGE DEPENDENCIES
   - List all npm packages needed
   - Provide package.json dependencies

## PART 2: PYTHON BACKEND

1. BACKEND ARCHITECTURE
   - Choose appropriate Python framework (Flask/FastAPI/Django)
   - RESTful API design
   - Project structure for backend

2. API ENDPOINTS
   - Define all required API endpoints
   - Request/response models
   - HTTP methods (GET, POST, PUT, DELETE)
   - Route handlers implementation

3. DATA MODELS
   - Define data models/schemas
   - Database models if needed
   - Validation logic

4. BUSINESS LOGIC
   - Service layer implementation
   - Data processing functions
   - Error handling

5. API INTEGRATION
   - CORS configuration for React frontend
   - Request/response formatting
   - Authentication/authorization if needed

6. BACKEND DEPENDENCIES
   - List all Python packages needed
   - Provide requirements.txt

7. BACKEND SETUP INSTRUCTIONS
   - Virtual environment setup
   - Installation steps
   - Running the backend server
   - Environment configuration

========================================
CRITICAL OUTPUT FORMAT REQUIREMENTS:
========================================

YOU MUST PROVIDE ACTUAL SOURCE CODE FILES, NOT SUMMARIES OR DESCRIPTIONS!

Each file MUST follow this EXACT format with NO exceptions:

FRONTEND FILE EXAMPLE:
```jsx
// filename: src/components/TodoList.jsx
import React from 'react';

function TodoList({{ todos, onToggle, onDelete }}) {{
  return (
    <div className="todo-list">
      {{todos.map(todo => (
        <div key={{todo.id}}>{{todo.text}}</div>
      ))}}
    </div>
  );
}}

export default TodoList;
```

BACKEND FILE EXAMPLE:
```python
# filename: backend/app.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_methods=["*"],
)

@app.get("/todos")
def get_todos():
    return {{"todos": []}}
```

REQUIRED FILES TO PROVIDE (with actual code):

FRONTEND:
1. ```jsx with // filename: src/App.jsx
2. ```jsx with // filename: src/components/TodoList.jsx
3. ```jsx with // filename: src/components/TodoItem.jsx
4. ```jsx with // filename: src/components/AddTodo.jsx
5. ```css with // filename: src/styles/App.css
6. ```json with // filename: package.json
7. ```jsx with // filename: src/index.jsx

BACKEND:
1. ```python with # filename: backend/app.py OR backend/main.py
2. ```python with # filename: backend/routes/todos.py
3. ```python with # filename: backend/models/todo.py
4. ```python with # filename: backend/schemas/todo.py
5. ```text with # filename: backend/requirements.txt

DO NOT provide descriptions like "I've created..." or "This will include...".
Provide ONLY the actual code blocks with proper filename markers.

Start each file immediately with the code block and filename comment."""
        print(f"  Implementation prompt prepared ({len(implementation_prompt)} characters)")

        print("\n[Step 3/9] Delegating to Claude API...")
        print("  Sending full-stack implementation task to AI subagent")

        # Delegate to orchestrator
        result = self.orchestrator.delegate_to_subagent(
            subagent_name=self.name,
            prompt=implementation_prompt,
            context={
                "phase": "implementation",
                "framework": "React + Python Backend",
                "output_format": "complete full-stack code with setup instructions"
            }
        )

        print("\n[Step 4/9] Processing implementation response...")
        if result.get("success"):
            response_text = result.get("response", "")
            response_length = len(response_text)
            print(f"  Response received ({response_length} characters)")

            # Check if response looks like a summary instead of code
            if response_length < 5000:
                print("  ⚠️  WARNING: Response seems too short for full code implementation")
            if "I've created" in response_text or "I've provided" in response_text or "Summary" in response_text[:200]:
                print("  ⚠️  WARNING: Response appears to contain descriptions instead of actual code")
                print("  This may result in missing files. Check the output carefully.")

            print("  Parsing full-stack code from response")

            print("\n[Step 5/9] Extracting frontend code blocks...")
            # Count frontend code blocks in response
            import re
            frontend_blocks = re.findall(r'```(?:jsx?|tsx?|javascript|typescript|json|css)', response_text)
            print(f"  Found {len(frontend_blocks)} frontend code blocks to extract")

            # Extract and create frontend source files
            print("\n[Step 6/9] Creating frontend source files...")
            files_info = self.create_source_files(response_text)
            print(f"  Created {files_info['files_created']} frontend files")
            if files_info['files_created'] <= 1:
                print("  ⚠️  WARNING: Very few frontend files created. Code blocks may be missing.")

            print("\n[Step 7/9] Extracting backend code blocks...")
            # Count backend code blocks in response
            backend_blocks = re.findall(r'```(?:python|py|text)', response_text)
            print(f"  Found {len(backend_blocks)} backend code blocks to extract")

            # Extract and create backend files
            print("\n[Step 8/9] Creating backend source files...")
            backend_info = self.create_backend_files(response_text)
            print(f"  Created {backend_info['files_created']} backend files")
            if backend_info['files_created'] == 0:
                print("  ⚠️  WARNING: No backend files created. Code blocks may be missing or incorrectly formatted.")

            # Add files info to result
            result["source_files"] = files_info
            result["backend_files"] = backend_info

            print("\n[Step 9/9] Finalizing implementation phase...")
            print("\n✓ Full-stack implementation completed successfully")
            print("\nImplementation deliverables:")
            print("  FRONTEND:")
            print("    - Project structure defined")
            print("    - React components implemented")
            print("    - State management configured")
            print("    - Styling approach implemented")
            print(f"    - {files_info['files_created']} frontend files created in src/")
            print("  BACKEND:")
            print("    - Python API server implemented")
            print("    - API endpoints defined")
            print("    - Data models created")
            print("    - CORS configured for frontend")
            print(f"    - {backend_info['files_created']} backend files created in backend/")
        else:
            error = result.get("error", "Unknown error")
            print(f"  Error occurred: {error}")
            print("\n[Step 9/9] Implementation phase failed")
            print("\n✗ Implementation phase failed")

        return result


if __name__ == "__main__":
    # For testing the agent standalone
    print("Implementation Agent - use through orchestrator")
