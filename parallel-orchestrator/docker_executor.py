#!/usr/bin/env python3
"""
Docker Executor Script
Runs inside Docker container to execute tasks.
Reads tasks from local file, executes them, and writes results to local directory.
"""

import os
import sys
import json
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List

# Add parent directory to path to import executor_agent
sys.path.insert(0, str(Path(__file__).parent))


def execute_task_simulated(task: Dict[str, Any], output_dir: Path, executor_id: int) -> Dict[str, Any]:
    """Execute task in simulated mode (for testing)"""
    task_output_dir = output_dir / task["id"]
    task_output_dir.mkdir(parents=True, exist_ok=True)

    start_time = time.time()

    print(f"[Executor {executor_id}] Executing task: {task['id']} - {task['name']}")
    print(f"  Description: {task['description']}")

    # Simulate work
    steps = 5
    for step in range(1, steps + 1):
        time.sleep(1)
        progress = (step / steps) * 100
        print(f"  Progress: {progress:.0f}% - Step {step}/{steps}")

    # Create simulated output files
    output_files = []
    for filename in ["implementation.py", "tests.py", "README.md"]:
        file_path = task_output_dir / filename
        with open(file_path, "w") as f:
            f.write(f"# {task['name']}\n\n")
            f.write(f"# Generated by Docker Executor {executor_id}\n")
            f.write(f"# Task ID: {task['id']}\n")
            f.write(f"# Task: {task['description']}\n\n")
            f.write(f"# Simulated implementation code\n")
            f.write(f"# In real mode, Claude would generate actual code here\n")
        output_files.append(str(file_path.relative_to(output_dir)))

    execution_time = time.time() - start_time

    result = {
        "task_id": task["id"],
        "executor_id": executor_id,
        "task_name": task["name"],
        "status": "completed",
        "execution_time": f"{execution_time:.2f}s",
        "output_files": output_files,
        "metrics": {
            "lines_of_code": 150 + (executor_id * 20),
            "test_coverage": 85,
            "complexity_score": 3
        },
        "container": os.environ.get("HOSTNAME", "unknown"),
        "completed_at": datetime.now().isoformat()
    }

    # Write result to file
    result_file = task_output_dir / "result.json"
    with open(result_file, 'w') as f:
        json.dump(result, f, indent=2)

    print(f"[Executor {executor_id}] Task {task['id']} completed successfully")
    return result


def execute_task_real(task: Dict[str, Any], requirements: str, output_dir: Path, executor_id: int) -> Dict[str, Any]:
    """Execute task using real Claude API"""
    from executor_agent import ExecutorAgent

    task_output_dir = output_dir / task["id"]
    task_output_dir.mkdir(parents=True, exist_ok=True)

    start_time = time.time()

    print(f"[Executor {executor_id}] Executing task with Claude: {task['id']} - {task['name']}")
    print(f"  Description: {task['description']}")

    try:
        # Create executor agent
        agent = ExecutorAgent(executor_id, task, str(task_output_dir))

        # Execute task with Claude
        result = agent.execute(requirements)

        execution_time = time.time() - start_time

        # Update result
        result["executor_id"] = executor_id
        result["execution_time"] = f"{execution_time:.2f}s"
        result["container"] = os.environ.get("HOSTNAME", "unknown")
        result["completed_at"] = datetime.now().isoformat()

        # Write result to file
        result_file = task_output_dir / "result.json"
        with open(result_file, 'w') as f:
            json.dump(result, f, indent=2)

        print(f"[Executor {executor_id}] Task {task['id']} completed successfully")
        print(f"  Files created: {len(result.get('output_files', []))}")
        print(f"  Execution time: {result['execution_time']}")

        return result

    except Exception as e:
        print(f"[Executor {executor_id}] Task {task['id']} failed: {e}")

        error_result = {
            "task_id": task["id"],
            "executor_id": executor_id,
            "task_name": task["name"],
            "status": "failed",
            "error": str(e),
            "execution_time": f"{time.time() - start_time:.2f}s",
            "container": os.environ.get("HOSTNAME", "unknown"),
            "completed_at": datetime.now().isoformat()
        }

        # Write error result
        result_file = task_output_dir / "result.json"
        with open(result_file, 'w') as f:
            json.dump(error_result, f, indent=2)

        return error_result


def main():
    """Main executor entry point"""
    print("="*80)
    print("Docker Executor Starting")
    print("="*80)

    # Get environment variables
    executor_id = int(os.environ.get("EXECUTOR_ID", "0"))
    output_dir = Path(os.environ.get("OUTPUT_DIR", "/output"))
    use_real = os.environ.get("USE_REAL_EXECUTORS", "0") == "1"
    requirements = os.environ.get("REQUIREMENTS", "")
    use_bedrock = os.environ.get("USE_BEDROCK", "0") == "1"

    # If using Bedrock, set Claude Code environment variable
    if use_bedrock:
        os.environ["CLAUDE_CODE_USE_BEDROCK"] = "1"
        bedrock_model = os.environ.get("BEDROCK_MODEL", "global.anthropic.claude-sonnet-4-5-20250929-v1:0")
        bedrock_region = os.environ.get("BEDROCK_REGION", "eu-central-1")
        print(f"Bedrock Mode: Enabled")
        print(f"Bedrock Region: {bedrock_region}")
        print(f"Bedrock Model: {bedrock_model}")

    print(f"Executor ID: {executor_id}")
    print(f"Output directory: {output_dir}")
    print(f"Mode: {'REAL' if use_real else 'SIMULATED'}")
    print(f"Requirements: {requirements[:100]}...")

    # Read tasks from file
    tasks_file = output_dir / "tasks.json"
    if not tasks_file.exists():
        print(f"ERROR: Tasks file not found: {tasks_file}")
        sys.exit(1)

    with open(tasks_file, 'r') as f:
        data = json.load(f)

    tasks = data.get("tasks", [])
    plan = data.get("plan", {})
    requirements = data.get("requirements", requirements)

    print(f"\nLoaded {len(tasks)} tasks")
    print("-"*80)

    # Execute each task
    results = []
    for i, task in enumerate(tasks, 1):
        print(f"\nTask {i}/{len(tasks)}: {task['id']}")
        print("-"*80)

        if use_real:
            result = execute_task_real(task, requirements, output_dir, executor_id)
        else:
            result = execute_task_simulated(task, output_dir, executor_id)

        results.append(result)

    print("\n" + "="*80)
    print("Executor Completed")
    print("="*80)
    print(f"Tasks executed: {len(results)}")
    completed = sum(1 for r in results if r.get('status') == 'completed')
    failed = sum(1 for r in results if r.get('status') == 'failed')
    print(f"Completed: {completed}")
    print(f"Failed: {failed}")
    print("="*80)

    # Exit with error if any tasks failed
    sys.exit(0 if failed == 0 else 1)


if __name__ == "__main__":
    main()
